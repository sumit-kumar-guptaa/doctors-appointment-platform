generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String              @id @default(cuid())
  clerkUserId          String              @unique
  email                String              @unique
  name                 String?
  imageUrl             String?
  role                 UserRole            @default(UNASSIGNED)
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  credits              Int                 @default(0)
  specialty            String?
  experience           Int?
  credentialUrl        String?
  description          String?
  verificationStatus   VerificationStatus? @default(PENDING)

  // Relations
  doctorAvailabilities Availability[]      @relation("DoctorAvailability")
  doctorAppointments   Appointment[]       @relation("DoctorAppointments")
  patientAppointments  Appointment[]       @relation("PatientAppointments")
  transactions         CreditTransaction[]
  payouts              Payout[]
}

model Availability {
  id        String     @id @default(cuid())
  doctorId  String
  startTime DateTime
  endTime   DateTime
  status    SlotStatus @default(AVAILABLE)

  // Relations
  doctor      User         @relation("DoctorAvailability", fields: [doctorId], references: [id], onDelete: Cascade)
  appointment Appointment?

  @@index([doctorId, startTime])
}

model Appointment {
  id                   String            @id @default(cuid())
  patientId            String
  doctorId             String
  availabilityId       String?           @unique
  status               AppointmentStatus @default(SCHEDULED)
  notes                String?
  patientDescription   String?
  videoSessionId       String?
  videoSessionToken    String?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt

  // Relations
  patient      User          @relation("PatientAppointments", fields: [patientId], references: [id], onDelete: Restrict)
  doctor       User          @relation("DoctorAppointments", fields: [doctorId], references: [id], onDelete: Restrict)
  availability Availability? @relation(fields: [availabilityId], references: [id], onDelete: SetNull)

  @@index([status, createdAt])
}

model CreditTransaction {
  id          String          @id @default(cuid())
  userId      String
  amount      Int
  type        TransactionType
  packageId   String?
  description String
  createdAt   DateTime        @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CreditPackage {
  id          String  @id @default(cuid())
  name        String
  description String
  credits     Int
  price       Float
  active      Boolean @default(true)
}

model Payout {
  id          String      @id @default(cuid())
  doctorId    String
  amount      Float
  status      PayoutStatus @default(PENDING)
  stripePayoutId String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  doctor User @relation(fields: [doctorId], references: [id], onDelete: Cascade)
}

// Enums
enum UserRole {
  UNASSIGNED
  PATIENT
  DOCTOR
  ADMIN
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum SlotStatus {
  AVAILABLE
  BOOKED
  BLOCKED
}

enum AppointmentStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
}

enum TransactionType {
  CREDIT_PURCHASE
  APPOINTMENT_DEDUCTION
  ADMIN_ADJUSTMENT
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}